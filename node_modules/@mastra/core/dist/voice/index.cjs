'use strict';

var chunkXB2TJ7LX_cjs = require('../chunk-XB2TJ7LX.cjs');
var chunkIIWRJFLQ_cjs = require('../chunk-IIWRJFLQ.cjs');
var chunkRWTSGWWL_cjs = require('../chunk-RWTSGWWL.cjs');

// src/voice/voice.ts
var _MastraVoice_decorators, _init, _a;
_MastraVoice_decorators = [chunkXB2TJ7LX_cjs.InstrumentClass({
  prefix: "voice",
  excludeMethods: ["__setTools", "__setLogger", "__setTelemetry", "#log"]
})];
exports.MastraVoice = class MastraVoice extends (_a = chunkIIWRJFLQ_cjs.MastraBase) {
  listeningModel;
  speechModel;
  speaker;
  constructor({
    listeningModel,
    speechModel,
    speaker
  } = {}) {
    super({
      component: "VOICE"
    });
    this.listeningModel = listeningModel;
    this.speechModel = speechModel;
    this.speaker = speaker;
  }
  traced(method, methodName) {
    return this.telemetry?.traceMethod(method, {
      spanName: `voice.${methodName}`,
      attributes: {
        "voice.type": this.speechModel?.name || this.listeningModel?.name || "unknown"
      }
    }) ?? method;
  }
};
exports.MastraVoice = /*@__PURE__*/(_ => {
  _init = chunkRWTSGWWL_cjs.__decoratorStart(_a);
  exports.MastraVoice = chunkRWTSGWWL_cjs.__decorateElement(_init, 0, "MastraVoice", _MastraVoice_decorators, exports.MastraVoice);
  chunkRWTSGWWL_cjs.__runInitializers(_init, 1, exports.MastraVoice);

  // src/voice/composite-voice.ts
  return exports.MastraVoice;
})();
// src/voice/composite-voice.ts
var CompositeVoice = class extends exports.MastraVoice {
  speakProvider;
  listenProvider;
  constructor({
    speakProvider,
    listenProvider
  }) {
    super();
    this.speakProvider = speakProvider;
    this.listenProvider = listenProvider;
  }
  async speak(input, options) {
    if (!this.speakProvider) {
      throw new Error("No speak provider configured");
    }
    return this.speakProvider.speak(input, options);
  }
  async listen(audioStream, options) {
    if (!this.listenProvider) {
      throw new Error("No listen provider configured");
    }
    return this.listenProvider.listen(audioStream, options);
  }
  async getSpeakers() {
    if (!this.speakProvider) {
      throw new Error("No speak provider configured");
    }
    return this.speakProvider.getSpeakers();
  }
};

exports.CompositeVoice = CompositeVoice;
