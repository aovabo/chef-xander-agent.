import { a2 as VariableReference, a9 as StepResult } from '../base-zjGki2_Z.cjs';
export { a4 as ActionContext, a3 as BaseCondition, ah as DependencyCheckOutput, ao as ExtractSchemaFromStep, ar as ExtractSchemaType, ap as ExtractStepResult, as as PathsToStringProps, ae as ResolverFunctionInput, af as ResolverFunctionOutput, a1 as RetryConfig, S as Step, Z as StepAction, a7 as StepCondition, a8 as StepConfig, a6 as StepDef, d as StepExecutionContext, a0 as StepGraph, an as StepId, aq as StepInputType, $ as StepNode, ai as StepResolverOutput, _ as StepVariableType, aa as StepsRecord, ag as SubscriberFunctionOutput, a5 as WhenConditionReturnValue, W as Workflow, ak as WorkflowActionParams, al as WorkflowActions, aj as WorkflowActors, e as WorkflowContext, ad as WorkflowEvent, ac as WorkflowLogMessage, n as WorkflowOptions, au as WorkflowResumeResult, ab as WorkflowRunResult, at as WorkflowRunState, am as WorkflowState, av as createStep } from '../base-zjGki2_Z.cjs';
import 'ai';
import '../base-DboIg_Cd.cjs';
import '@opentelemetry/api';
import '../index-mKY1XrpK.cjs';
import 'stream';
import 'pino';
import '@opentelemetry/sdk-trace-base';
import 'sift';
import 'zod';
import 'json-schema';
import '../types-CwTG2XyQ.cjs';
import '../deployer/index.cjs';
import '../bundler/index.cjs';
import '../vector/index.cjs';
import '../vector/filter/index.cjs';
import '../tts/index.cjs';
import '../voice/index.cjs';

declare function isErrorEvent(stateEvent: any): stateEvent is {
    type: `xstate.error.actor.${string}`;
    error: Error;
};
declare function isTransitionEvent(stateEvent: any): stateEvent is {
    type: `xstate.done.actor.${string}`;
    output?: unknown;
};
declare function isVariableReference(value: any): value is VariableReference<any, any>;
declare function getStepResult(result?: StepResult<any>): any;
declare function getSuspendedPaths({ value, path, suspendedPaths, }: {
    value: string | Record<string, string>;
    path: string;
    suspendedPaths: Set<string>;
}): void;
declare function isFinalState(status: string): boolean;
declare function isLimboState(status: string): boolean;
declare function recursivelyCheckForFinalState({ value, suspendedPaths, path, }: {
    value: string | Record<string, string>;
    suspendedPaths: Set<string>;
    path: string;
}): boolean;
declare function getActivePathsAndStatus(value: Record<string, any>): Array<{
    stepPath: string[];
    stepId: string;
    status: string;
}>;
declare function mergeChildValue(startStepId: string, parent: Record<string, any>, child: Record<string, any>): Record<string, any>;
declare const updateStepInHierarchy: (value: Record<string, any>, targetStepId: string) => Record<string, any>;
declare function getResultActivePaths(state: {
    value: Record<string, string>;
    context: {
        steps: Record<string, any>;
    };
}): Map<string, {
    status: string;
    suspendPayload?: any;
}>;

export { StepResult, VariableReference, getActivePathsAndStatus, getResultActivePaths, getStepResult, getSuspendedPaths, isErrorEvent, isFinalState, isLimboState, isTransitionEvent, isVariableReference, mergeChildValue, recursivelyCheckForFinalState, updateStepInHierarchy };
